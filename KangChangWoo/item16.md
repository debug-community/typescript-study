# Item 16

## Item.16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

*요약*

- 배열은 객체이므로 키는 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다.
- 인덱스 시그니처에 `number` 를 사용하기보다 `Array` 나 튜플, 또는 `ArrayLike` 타입을 사용하는 것이 좋다.

---

자바스크립트는 이상하게 동작하기로 유명한 언어이다. 그중 가장 악명 높은 것은 암시적 타입 강제와 관련된 부분이다.

```jsx
> "0" == 0
true
```

다행히도 암시적 타입 강제와 관련된 문제는 대부분 `===` 와 `!==` 를 사용해 해결이 가능하다.

자바스크립트 객체 모델에도 이상한 부분들이 있으며, 이 중 일부는 타입스크립트 타입 시스템으로 모델리오디기 때문에 자바스크립트 객체 모델을 이해하는 것이 중요하다.

자바스크립트에서 객체란 키/값 쌍의 모음이다. 키는 보통 문자열이다.(ES2015 이후로는 심벌일 수 있다.) 그리고 값은 어떤 것이든 될 수 있다.

파이썬이나 자바에서 볼 수 있는 ‘해시 가능’ 객체라는 표현이 자바스크립트에는 없다. 만약 더 복잡한 객체를 키로 사용하려고 하면, `toString` 메서드가 호출되어 객체가 문자열로 변환된다.

```jsx
> x = {}
{}

> x[[1, 2, 3]] = 2
2

> x
{ '1,2,3': 1 }
```

특히, 숫자는 키로 사용할 수 없다. 만약 속성 이름으로 숫자를 사용하려고 하면, 자바스크립트 런타임은 문자열로 변환할 것이다.

```jsx
> { 1: 2, 3: 4 }
{ '1': 2, '3': 4 }
```

이번엔 배열을 알아보자. 배열은 분명히 객체이다.

```jsx
> typeof []
'object'
```

그러니 숫자 인덱스를 사용하는 것이 당연하다.

```jsx
> x = [1, 2, 3]
[1, 2, 3]

> x[0]
1
```

이상하게 보일지 모르지만, 앞의 인덱스들은 문자열로 변환되어 사용된다. 문자열 키를 사용해도 역시 배열의 요소에 접근할 수 있다.

```jsx
> x['1']
2
```

`Object.keys` 를 이용해 배열의 키를 나열해 보면, 키가 문자열로 출력된다.

```jsx
> Object.keys(x)
[ '0', '1', '2' ]
```

타입스크립트는 이러한 혼란을 바로잡기 위해 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식한다. `Array` 에 대한 타입 선언은 `lib.es5.d.ts` 에서 확인할 수 있다.

```jsx
interface Array<T> {
	// ...
	[n: number]: T;
}
```

런타임에는 ECMAScript 표준이 서술하는 것처럼 문자열 키로 인식하므로 이 코드는 완전히 가상이라고 할 수 있지만, 타입 체크 시점에 오류를 잡을 수 있어 유용하다.

```jsx
const xs = [1, 2, 3];
const x0 = xs[0]; // OK
const x1 = xs['1'];
	// ~~ 인덱스 식이 'number' 형식이 아니므로
	// ~~ 요소에 암시적으로 'any' 형식이 있습니다.

function get<T>(array: T[], k: string): T {
	return array[k];
		// ~~ 인덱스 식이 'number' 형식이 아니므로
		// ~~ 요소에 암시적으로 'any' 형식이 있습니다.
}
```

이 코드는 실제로 동작하지 않는다. 그리고 타입스크립트 타입 시스템의 다른 것들과 마찬가지로, 타입 정보는 런타임에 제거된다.

한편 `Object.keys` 같은 구문은 여전히 문자열로 반환된다.

```jsx
const keys = Object.keys(xs); // 타입이 string[]
for (const key in xs) {
	key; // 타입이 string
	const x = xs[key]; // 타입이 number
}
```

`string` 이 `number` 에 할당될 수 없기 때문에, 예제의 마지막 줄이 동작하는 것이 이상하게 보일 수 있다. 배열을 순회하는 코드 스타일에 대한 실용적인 허용이라고 생각하는 것이 좋다. 자바스크립트에서는 흔한 일이자만, 이 예제가 배열을 순회하기에 좋은 방법은 아니다. 인덱스에 신경 쓰지 않는다면, `for-of` 를 사용하는 게 더 좋다.

```jsx
for (const x of xs) {
	x; // 타입이 number
}
```

만약 인덱스의 타입이 중요하다면, `number` 타입을 제공해 줄 `Array.prototype.forEach` 를 사용하면 된다.

```jsx
xs.forEach((x, i) => {
	i; // 타입이 number
	x; // 타입이 number
});
```

루프 중간에 멈춰야 한다면, C 스타일인 for(;;) 루프를 사용하는 것이 좋다.

```jsx
for (let i = 0; i < xs.length; i++) {
	const x = xs[i];
	if (x < 0) break;
}
```

**타입이 불확실하다면, (대부분의 브라우저와 자바스크립트 엔진에서) `for-in` 루프는 `for-of` 또는 C 스타일 `for` 루프에 비해 몇 배나 느리다.**

- 🔥 왜 `for-in`이 느릴 수 있는가?
    
    ### 1. **모든 열거 가능한 속성을 검사**
    
    `for-in`은 단순히 배열의 인덱스만 도는 게 아니라:
    
    - **자체 속성 + 상속된 속성**
    - **열거 가능한 속성만**
    
    을 포함해서 전부 검사합니다. 즉, 배열 이외의 추가 속성까지 포함될 수 있어요.
    
    ```
    ts
    복사편집
    Array.prototype.foo = 123;
    
    const arr = [1, 2, 3];
    for (const i in arr) {
      console.log(i); // '0', '1', '2', 'foo'
    }
    
    ```
    
    > 배열에 추가된 커스텀 속성까지 포함됨 → 성능 저하 + 예기치 않은 결과
    > 
    
    ---
    
    ### 2. **문자열 인덱스 사용**
    
    - `for-in`은 인덱스를 **문자열로 반환**합니다 (`"0"`, `"1"` 등)
    - 숫자처럼 생겼지만 **타입은 string**
    - 배열 접근 시 암묵적으로 `arr["1"]` 형태로 접근 → **비효율적**
    
    ---
    
    ### 3. **JIT 최적화에 불리함**
    
    대부분의 JS 엔진(V8, SpiderMonkey 등)은 반복문을 JIT(Just-In-Time) 컴파일로 최적화합니다.
    
    - `for-of`나 `C 스타일 for`은 **메모리 구조가 예측 가능**해서 최적화가 잘 됨
    - `for-in`은 **배열이 아닐 수도 있고, 동적으로 속성이 추가될 수도 있어서 최적화가 어려움**
    
    > 특히 배열에서 for-in을 쓰면 배열처럼 취급하지 않게 되어 내부 최적화 경로에서 벗어나요.
    > 

인덱스 시그니처가 `number` 로 표현되어 있다면 입력한 값이 `number` 여야 한다는 것을 의미하지만(`for-in` 루프를 제외하고), 실제 런타임에 사용되는 키는 `string` 타입이다.

이 부분이 혼란스러울 수 있는데, 일반적으로 `string` 대신 `number` 를 타입의 인덱스 시그니처로 사용할 이유는 많지 않다. 만약 숫자를 사용하여 인덱스할 항목을 지정한다면 `Array` 또는 튜플 타입을 대신 사용하게 될 것이다. `number` 를 인덱스 타입으로 사용하면 숫자 속성이 어떤 특별한 의미를 지닌다는 오해를 불러 일으킬 수 있다.

한편 `Array` 타입이 사용하지도 않을 `push` 나 `concat` 같은 다른 속성(프로토타입에서 온)을 가지는 게 납득하기 어려울 수 있다. 납득하기 어렵다는 것은 구조적인 고려를 하고 있다는 뜻이기 때문에 타입스크립트를 잘 이해하고 있다고 볼 수 있다.

어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트에 있는 `ArrayLike` 타입을 사용한다.

```jsx
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
	if (i < xs.length) {
		return xs[i];
	}
	throw new Error(`배열의 끝을 지나서 ${i}를 접근하려고 했습니다.`)
}
```

이 예제는 길이와 숫자 인덱스 시그니처만 있다. 이런 경우가 실제로는 드물지만 필요하다면 `ArrayLike` 사용해야 한다. 그러나 `ArrayLike` 를 사용하더라도 키는 여전히 문자열이라는 점을 잊지 말아야 한다.

```jsx
const tupleLike: ArrayLike<string> = {
	'0': 'A',
	'1': 'B',
	length: 2,
}; // 정상
```
