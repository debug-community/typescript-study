# Item 21

## item.21 타입 넓히기

요약

- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
- 동작에 영향을 줄 수 있는 방법인 `const` , 타입 구문, 문맥, `as const` 에 익숙해져야 한다.

---

런타임에 모든 변수는 유일한 값을 가진다. 그러나 타입스크립트가 작성된 코드를 체크하는 적정 분석 시점에, 변수는 ‘가능한’ 값들의 집합인 타입을 가진다. 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다.

이 말은 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다는 뜻이다. 타입스크립트에서는 이러한 과정을 ‘넓히기(`widening` )라고 부른다. 넓히기의 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있을 것이다.

벡터를 다루는 라이브러리를 작성한다고 가정해보자. 3D 벡터에 대한 타입과 그 요소들의 값을 얻는 함수를 작성해보자.

```jsx
interface Vector3 { 
	x: number;
	y: number;
	z: number;
}

function getComponent(vetcor: Vetcor3, axis: 'x' | 'y' | 'z') {
	return vector[axis];
}
```

`Vector3` 함수를 사용한 다음 코드는 런타임에 오류없이 실행되지만, 편집기에서는 오류가 표시된다.

```jsx
let x = 'x';
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x);
	// ~~~ 'string' 형식의 인수는 '"x" | "y" | "z"'
	// ~~~ 형식의 매개변수에 할당될 수 없습니다.
	
// -> x의 타입이 string으로 추론되기 때문이다.
// 해결하려면
// let x = 'x' as const 사용하거나 const로 선언 또는 :'x' 로 타입 선언
```

실행은 잘 되지만 편집기에서는 오류가 발생한다.

`getComponent` 함수는 두 번째 매개변수에 `"x" | "y" | "z"` 타입을 기대했지만, `x` 의 타입은 할당 시점에 넓히기가 동작해서 `string` 으로 추론되었다. `string` 타입은 `"x" | "y" | "z"` 타입에 할당이 불가능하므로 오류가 된 것이다.

타입 넓히기가 진행될 때, 주어진 값으로 추론 가능한 타입이 여러 개이기 때문에 과정이 상당히 모호하다. 다음 코드를 예로 들어보자.

```jsx
const mixed = ['x', 1];
```

`mixed` 의 타입이 어떻게 추론되는지 살펴보자. 다음은 `mixed` 의 타입이 될 수 있는 후보들이다. 후보가 상당히 많은 것을 알 수 있다.

- `('x' | 1)[]`
- `['x', 1]`
- `[string, number]`
- `readonly [string, number]`
- `(string | number)[]`
- `readonly (string | number)[]`
- `[any, any]`
- `any[]`

정보가 충분하지 않다면 `mixed` 가 어떤 타입으로 추론되어야 하는지 알 수 없다. 그러므로 타입스크립트는 작성자의 의도를 추측한다. (이 경우에는, `(string | number) []` 로 추측한다.) 그러나 타입스크립트가 아무리 영리하더라도 사람의 마음까지 읽을 수는 없고 따라서 추측한 답이 항상 옳을 수도 없다.

처음의 예제에서 타입스크립트는 다음 예제와 같은 코드를 예상했기 때문에 `x` 의 타입을 `string` 으로 추론했다.

```jsx
let x = 'x';
x = 'a';
x = 'Four score and seven years ago...';
```

자바스크립트에서는 다음처럼 작성해도 유효하다.

```jsx
let x = 'x';
x = /x|y|z/;
x = ['x', 'y', 'z'];
```

타입스크립트는 `x` 의 타입을 `string` 으로 추론할 때, 명확성과 유연성 사이의 균형을 유지하려고 한다. 일반적인 규칙은 변수가 선언된 후로는 타입이 바뀌지 않아야 하므로, `string | RegExp` 나 `string | string[]` 이나 `any` 보다는 `string` 을 사용하는게 낫다.

타입스크립트는 넓히기의 과정을 제어할 수 있도록 몇 가지 방법을 제공한다. 넓히기 과정을 제어할 수 있는 첫 번째 방법은 `const` 이다. 만약 `let` 대신 `const` 로 변수를 선언하면 더 좁은 타입이 된다. 실제로 `const` 를 사용하면 앞에서 발생한 오류가 해결된다.

```jsx
const x = 'x'; // 타입이 'x'
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // 정상
```

이제 `x` 는 재할당될 수 없으므로 타입스크립트는 의심의 여지 없이 더 좁은 타입(`"x"` )으로 추론할 수 있다. 그리고 문자 리터럴 타입 `"x"` 는 `"x"|"y"|"z"` 에 할당 가능하므로 코드가 타입 체커를 통과한다.

그러나 `const` 는 만능이 아니다. 객체와 배열의 경우에는 여전히 문제가 있다. 아이템 초반에 있는 `mixed` 예제(`const mixed = ['x', 1];` )는 배열에 대한 문제를 보여 준다. 튜플 타입을 추론해야 할지, 요소들은 어떤 타입으로 추론해야 할지 알 수 없다. 비슷한 문제가 객체에서도 발생한다. 다음 코드는 자바스크립트에서 정상이다.

```jsx
const v = {
	x: 1,
};
v.x = 3;
v.x = '3';
v.y = 4;
v.name = 'Pythagoras';
```

`v` 의 타입은 구체적인 정도에 따라 다양한 모습으로 추론될 수 있다. 가장 구체적인 경우라면 `{readonly x: 1}` 이다. 조금 추상적으로는 `{x: number}` 이다. 가장 추상적이라면 `{[key: string]: number}` 또는 `object` 가 될 것이다.

객체의 경우 타입스크립트의 넓히기 알고리즘은 각 요소를 `let` 으로 할당된 것처럼 다룬다. 그래서 `v` 의 타입은 `{x: number}` 가 된다. 덕분에 `v.x` 를 다른 숫자로 재할당할 수 있게 되지만 `string` 으로는 안된다. 그리고 다른 속성을 추가하지도 못한다.

따라서 다음 코드는 마지막 세 문장에서 오류가 발생한다.

```jsx
const v = {
	x: 1,
};
v.x = 3; // 정상
v.x = '3';
// ~~ '"3"' 형식은 'number' 형식에 할당할 수 없습니다.
v.y = 4;
// ~~ '{x: number;}' 형식에 'y' 속성이 없습니다.
v.name = 'Pythagoras';
// ~~~ '{x: number;}' 형식에 'name' 속성이 없습니다.
```

앞에서 언급했듯이 타입스크립트는 명확성과 유연성 사이의 균형을 유지하려고 한다. 오류를 잡기 위해서는 충분히 구체적으로 타입을 추론해야 하지만, 잘못된 추론(false positive)을 할 정도로 구체적으로 수행하지는 않는다. 예를 들어, `1` 과 같은 값으로 초기화 되는 속성을 적당히 `number` 의 타입으로 추론한다.

타입 추론의 강도를 직접 제어하려면 타입스크립트의 기본 동작을 재정의해야 한다. 타입스크립트의 기본 동작을 재정의하는 세 가지 방법이 있다.

첫 번째, 명시적 타입 구문을 제공하는 것이다.

```jsx
const v: { x: 1|3|5 } = {
	x: 1,
}; // 타입이 { x: 1|3|5; }
```

두 번째, 타입 체커에 추가적인 문맥을 제공하는 것이다. (예를 들어, 함수의 매개변수로 값을 전달)

세 번째, `const` 단언문을 사용하는 것이다. `const` 단언문과 변수 선언에 쓰이는 `let` 이나 `const` 와 혼동해서는 안된다. `const` 단언문은 온전히 타입 공간의 기법이다.

다음 예제를 통해 각 변수에 추론된 타입의 차이점을 살펴보자.

```jsx
const v1 = {
	x: 1,
	y: 2,
}; // 타입은 { x: number; y: number; }

const v2 = {
	x: 1 as const,
	y: 2,
}; // 타입은 { x: 1, y: number; }

const v3 = {
	x: 1,
	y: 2,
} as const; // 타입은 { readonly x: 1; readonly y: 2; }
```

값 뒤에 `as const` 를 작성하면, 타입스크립트는 최대한 좁은 타입으로 추론한다. `v3` 에는 넓히기가 동작하지 않았다. `v3` 이 진짜 상수라면, 주석에 보이는 추론된 타입이 실제로 원하는 형태일 것이다. 또한 배열을 튜플 타입으로 추론할 때에도 `as const` 를 사용할 수 있다.

```jsx
const a1 = [1, 2, 3]; // 타입이 number[]
const a2 = [1, 2, 3] as const; // 타입이 readonly [1, 2, 3]
```

넓히기로 인해 오류가 발생한다고 생각되면, 명시적 타입 구문 또는 `const` 단언문을 추가하는 것을 고려해야 한다. 단언문으로 인해 추론이 어떻게 변화하는지 편집기에서 주기적으로 타입을 살펴봐야 한다.
